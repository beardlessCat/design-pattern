# 适配者模式(adapter)
## 一、概述
### 1.描述
用适配器（Adepter）去将目标（Target）和被适配者（Adeptee）两者联系起来，从而使得Target可以使用Adeptee中的属性方法。

对象适配器与类适配器实现的一个重点就是在适配器中重写目标（Target）的方法，使得调用Target的方法可以调用Adeptee。
### 2.分类
主要分为类适配器及对象适配器
## 二、示例
### 1.类适配器
- 类图
![类适配器](https://img-blog.csdnimg.cn/d851cdc7f1e84d41974061e33eea70cd.gif)
- 示例
con.adapter.base.classes
### 2.对象化适配器
- 类图
![对象适配器](https://img-blog.csdnimg.cn/8a40508fffef470fa30453fff507b242.gif)
- 示例
- con.adapter.base.object
## 三、典型案例
### 1.背景描述
当前系统缓存功能只有Memcached,由于各种原因，需要增加redis作为缓存。
### 2.各个角色
- MemcachedCach：系统中的老接口，也是该设计模式中的被适配者。
- MemcachedCachAdapter：适配器，用于进行新老接口的适配。
- PlateCach：适配者接口。
- AbstractPlateCach：适配者抽象类，用于处理接口中的部分公告逻辑。
- RedisCach：新的redis缓存实现类
- AdapterTest：模拟调用端
### 3.具体实现
详见代码实例（com.adapter.advanced）
## 四.应用场景
一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。
- 封装有缺陷的接口设计
假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。
- 统一多个类的接口设计
某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。
- 替换依赖的外部系统
当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。
- 兼容老版本接口
在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。
- 适配不同格式的数据
适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。
